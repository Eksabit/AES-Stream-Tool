# AES Stream Tool

Утилита на Python для безопасного потокового шифрования и расшифровки файлов с помощью AES‑256 GCM. Поддерживает файлы любого размера (шифрует по чанкам), показывает прогресс в консоли, включает генератор «читаемых» паролей и простые инструменты работы с ключами.

---

Содержание
- Особенности
- Требования
- Быстрый старт (установка и запуск)
- Примеры использования
- Интерактивный режим (шаг‑за‑шагом для обычного пользователя)
- Пояснения по безопасности (простым языком)
- Формат зашифрованного файла (коротко)
- Частые ошибки и как их исправить
- Возможные улучшения

---

Особенности
- AES‑256 в режиме GCM — аутентифицированное шифрование (проверяет целостность данных).
- Потоковое шифрование (поддержка файлов любого размера) — файл разбивается на чанки; каждый чанк зашифровывается отдельно.
- Прогресс‑бар в консоли при шифровании/расшифровке.
- Генератор читаемых паролей (несколько уровней сложности).
- Интерактивное меню для пользователей без опыта командной строки.
- Возможность сохранить/загрузить 32‑байтный ключ в файл.

---

Требования
- Python 3.8 или новее
- Пакет cryptography

Установка зависимостей:
pip install cryptography

Сохраните скрипт как aes_stream_tool.py и сделайте исполняемым (по желанию):
chmod +x aes_stream_tool.py

---

Быстрый старт

1) Сохраните aes_stream_tool.py рядом с README.
2) Установите зависимость:
   pip install cryptography
3) Запустите интерактивный режим:
   python aes_stream_tool.py

Или используйте параметры командной строки:
- Шифрование:
  python aes_stream_tool.py --encrypt input.txt output.aes --keyfile key.bin
- Расшифровка:
  python aes_stream_tool.py --decrypt input.aes output.txt --keyfile key.bin
- Генерация паролей:
  python aes_stream_tool.py --gen-pass 5 12 3
  (5 паролей, длина ~12, уровень сложности 3)

---

Примеры использования (пошагово)

1) Создать ключ и сохранить его (GUI‑подобно через меню)
- Запустите: python aes_stream_tool.py
- В меню выберите пункт 4 — «Сгенерировать и сохранить ключ».
- Укажите путь, например key.bin.
- Скрипт сохранит 32‑байтный ключ в key.bin и выведет его в base64 — сохраните это где‑нибудь в надёжном месте.

2) Зашифровать файл (интерактивно)
- Запустите: python aes_stream_tool.py
- Выберите 1) Зашифровать файл
- Укажите путь к входному файлу (например document.txt)
- Укажите путь для сохранения зашифрованного файла (например document.aes)
- Если ключ ещё не загружен, программа предложит:
  - Ввести пароль (и сгенерировать ключ через KDF),
  - Ввести base64 ключа,
  - Или сгенерировать новый ключ.
- После подтверждения начнётся шифрование и вы увидите прогресс‑бар. По завершении получите сообщение о количестве чанков и успешном завершении.

3) Расшифровать файл (интерактивно)
- Запустите: python aes_stream_tool.py
- Выберите 2) Расшифровать файл
- Укажите путь к зашифрованному файлу (document.aes)
- Укажите путь для сохранения расшифрованного файла (например document_decrypted.txt)
- Укажите ключ (загрузите key.bin через пункт 5 в меню или введите base64/пароль)
- Программа покажет прогресс и сохранит расшифрованный файл.

4) Быстрая команда (CLI)
- Генерация ключа:
  python aes_stream_tool.py --gen-key
  → Выведет base64 ключа (можно сохранить в файл).
- Шифрование с файлом ключа:
  python aes_stream_tool.py --encrypt secret.txt secret.aes --keyfile key.bin
- Расшифровка:
  python aes_stream_tool.py --decrypt secret.aes secret.txt --keyfile key.bin

5) Генератор читаемых паролей
- Через меню: выберите пункт 3 и следуйте подсказкам.
- Через CLI:
  python aes_stream_tool.py --gen-pass 10 16 2
  → Сгенерирует 10 паролей длиной ~16 символов уровня 2.

---

Интерактивный режим — подробная инструкция для новичка

1. Запуск
   python aes_stream_tool.py

2. Главное меню — выбор действий:
   1) Зашифровать файл — вводите пути к исходному и выходному файлу; если ключ не загружен, программа предложит варианты получения ключа.
   2) Расшифровать файл — аналогично, укажите зашифрованный файл и куда сохранить результат.
   3) Сгенерировать читаемые пароли — введите количество, длину и уровень сложности; пароли выведутся в консоль.
   4) Сгенерировать и сохранить ключ — полезно, если вы хотите получить файл key.bin для последующего использования.
   5) Загрузить ключ из файла — выберите уже сохранённый key.bin (должен быть ровно 32 байта).
   0) Выход.

3. Получение ключа (варианты)
   - Ввести пароль: программа применит KDF (scrypt) к паролю и сгенерирует 32‑байтный ключ. Salt будет выведен в base64 — сохраните его, если захотите восстановить ключ по паролю.
   - Ввести base64 ключа: если у вас есть ключ в base64 (например, вы сохранили его при генерации), вставьте его.
   - Сгенерировать случайный ключ: программа создаст новый ключ (и предложит сохранить в файл при выборе пункта 4).

4. Размер чанка
   - По умолчанию 64 KiB (65536 байт). Можно изменить при шифровании — больший размер даёт меньше накладных данных, меньший — больше метаданных, но потенциально проще восстановление частей файла.

---

Пояснения по безопасности (простыми словами)

- AES‑256 GCM — современный и безопасный режим, который шифрует данные и дополнительно проверяет, не были ли они изменены.
- Nonce (одноразовый вектор) должен быть уникален для каждого чанка при том же ключе. В программе nonce генерируется как base_nonce XOR counter, где counter увеличивается для каждого чанка. Это обеспечивает уникальность при обычном использовании.
- Не используйте один и тот же ключ много-много раз для шифрования больших объёмов с тем же base_nonce и одинаковыми counter'ами — это может ослабить безопасность. Для повседневного использования (шифрование файлов по одному за другим) обычного поведения достаточно.
- Если вы сохраняете ключ в файл — храните файл в безопасном месте (например, домашний каталог с правами доступа 600).
- При использовании пароля для генерации ключа (через scrypt) обязательно сохраните salt — без него тот же пароль не даст тот же ключ.
- При повреждении одного чанка (например, часть файла испорчена) расшифровка на нём завершится с ошибкой — остальные чанки при этом не будут автоматически восстановлены. Держите резервные копии важных данных.

---

Формат зашифрованного файла (коротко, для понимания)
- Заголовок содержит: magic (AESG), версия, salt (16 байт), base_nonce (12 байт), chunk_size (4 байта).
- Затем идут записи для каждого чанка: 4 байта длины шифртекста + сам шифртекст (включая 16‑байтный тег).
- Это позволяет расшифровывать файл по частям и проверять целостность каждого чанка.

---

Частые ошибки и их решения

- Ошибка "Bad file format (magic mismatch)":
  → Вы пытаетесь расшифровать не тот файл. Убедитесь, что файл был зашифрован этой утилитой.

- Ошибка при загрузке ключа: «Ключ должен быть 32 байта»:
  → Файл ключа повреждён или вы указали неверный файл. Сгенерируйте новый ключ или используйте base64 вывод при генерации.

- Ошибка проверки GCM (authentication failed):
  → Либо ключ неверный, либо файл/чанк повреждён. Попробуйте загрузить правильный ключ и повторить. Если файл был повреждён — восстановление невозможно без резервной копии.

- Медленное шифрование / расшифровка:
  → Уменьшите накладные расходы, увеличив размер чанка (например, до 256 KiB), если у вас достаточно памяти.

---

## Рекомендации по выбору размера чанка (chunk)

По умолчанию: 64 KiB — универсальный выбор.

### Малые файлы (несколько КБ — несколько МБ)
- Рекомендуемый chunk: **16–64 KiB**  
- Причина: файл в любом случае будет обработан быстро; маленький или средний размер снижает накладные операции и не тратит лишнюю память.

### Обычные файлы и документы (несколько МБ — сотни МБ)
- Рекомендуемый chunk: **64–256 KiB**  
- Причина: компромисс между скоростью и памятью; уменьшает накладные данные и даёт стабильную скорость на HDD/SSD.

### Большие архивы и бэкапы (гигабайты)
- Рекомендуемый chunk: **256 KiB — 2 MiB**  
- Причина: минимизировать количество чанков/метаданных и повысить пропускную способность, особенно при последовательном чтении/записи.  
- Важно: при использовании очень больших chunk (>1 MiB) убедитесь, что у вас достаточно оперативной памяти и что размер счётчика/nonce безопасен для количества чанков.

### Быстрые диски / NVMe / RAID
- Рекомендуемый chunk: **256 KiB — 1 MiB**  
- Причина: быстрый ввод/вывод позволяет эффективно использовать большие блоки и уменьшить накладные операции; даёт лучшую пропускную способность.

### Сетевые операции (шифрование перед отправкой по сети)
- Рекомендуемый chunk: **16–128 KiB**  
- Причина: уменьшить задержки при отправке каждого блока; найти баланс между overhead и latency.

### Ограниченная память (встроенные устройства, старые ПК)
- Рекомендуемый chunk: **8–64 KiB**  
- Причина: не загружать память — при малых чанках программа использует мало RAM.

---

## Практические советы
- Если не уверены — оставьте **64 KiB**.
- Для максимальной скорости на современном ПК с SSD попробуйте **256 KiB** и замерьте время; если память позволяет, увеличьте до **1 MiB** и сравните.
- Для резервных копий / больших архивов ставьте **512 KiB–1 MiB**, чтобы уменьшить накладные данные.
- Не делайте chunk настолько большим, чтобы он превышал доступную RAM (учтите, что одновременно может быть открыто несколько потоков/операций).

Возможные улучшения (если захотите дорабатывать)
- Автоматическая ротация ключей при достижении лимита счётчика.
- Встроенная поддержка восстановления ключа по паролю, хранение параметров KDF прямо в заголовке.
- Вывод ETA и скорости (KB/s) в прогресс‑баре.
- Опция export/import в base64/JSON для удобной передачи по сети.
- GUI (простое графическое приложение).

---

Контакты / помощь
Если нужна помощь по использованию или доработке скрипта, опишите задачу в чате: укажите используемую команду, полные сообщения об ошибках и пример входных данных (если возможно).

---

Лицензия и предупреждение
Код предоставлен «как есть». Используйте на свой страх и риск. Для важных данных держите резервные копии и тестируйте процесс восстановления заранее.

--- 

Спасибо за использование.
